name: iOS CI

on: ["push", "pull_request"]

jobs:
  build:
    env: 
      ERLANG_VERSION: 26.2.5.6
      ELIXIR_VERSION: 1.16.3-otp-26
      APP_BUNDLE_ID: "com.sensocto.iOSErlang"

    runs-on: macos-latest

    steps:
    - uses: actions/checkout@v4
    - name: Install brew dependencies
      run: |
        brew install wxwidgets asdf

    - name: Configure asdf versions
      shell: bash
      run: |
        # Clean tool-versions file
        echo '' > .tool-versions
        echo "erlang ${{ env.ERLANG_VERSION }}" >> .tool-versions
        echo "elixir ${{ env.ELIXIR_VERSION }}" >> .tool-versions
        echo "nodejs 23.9.0" >> .tool-versions
    
    - name: Asdf Cache
      uses: actions/cache@v3
      id: asdf-cache
      with:
        path: |
          /Users/runner/.asdf
          ~/.asdf
        key: macos-asdf-${{ hashFiles('.tool-versions') }}
        restore-keys: |
          macos-asdf-

    - name: Configure shell environment
      run: |
        # Set up persistent asdf environment
        source $(brew --prefix asdf)/libexec/asdf.sh
        echo 'export ASDF_DIR="/Users/runner/.asdf"' >> $GITHUB_ENV
        echo 'export ASDF_DATA_DIR="/Users/runner/.asdf"' >> $GITHUB_ENV
        echo "/Users/runner/.asdf/shims" >> $GITHUB_PATH
        echo "/Users/runner/.asdf/bin" >> $GITHUB_PATH

    - name: Validate asdf installation
      id: validate-asdf
      shell: bash
      run: |
        # Load asdf without failing
        source $(brew --prefix asdf)/libexec/asdf.sh || true
        
        # Reshim after cache restore to ensure binaries are available
        asdf reshim || true
        
        # Verify installations
        if ! (asdf which erl && asdf which elixir && asdf which mix) > /dev/null 2>&1; then
          echo "::warning::asdf installations need rebuild"
          echo "ASDF_INVALID=true" >> $GITHUB_ENV
          rm -rf /Users/runner/.asdf/installs/* 2>/dev/null || true
        else
          echo "asdf installations valid:"
          asdf current
          # Verify PATH and shims
          echo "PATH: $PATH"
          ls -la /Users/runner/.asdf/shims/ || true
        fi

    - name: Configure asdf version manager
      run: |
        echo '. $(brew --prefix asdf)/libexec/asdf.sh' >> ~/.bashrc
        echo '. $(brew --prefix asdf)/libexec/asdf.sh' >> .env

        # echo '. $(brew --prefix asdf)/etc/bash_completion.d/asdf.bash' >> ~/.bashrc
        source ~/.bashrc # Load asdf into the current shell

    - name: "Installing Erlang/Elixir"
      if: steps.asdf-cache.outputs.cache-hit != 'true' || env.ASDF_INVALID == 'true'
      run: |
        . $(brew --prefix asdf)/libexec/asdf.sh
        # Install plugins if needed
        asdf plugin add erlang || true
        asdf plugin add elixir || true
        asdf plugin add nodejs || true
        
        # Configure and install
        export KERL_CONFIGURE_OPTIONS="--enable-parallel-configure --with-wxdir=`brew --prefix wxwidgets` --disable-jit --without-javac --disable-debug CXX='gcc -std=c++11'"
        asdf install
        asdf current
        
        # Ensure mix is available
        which mix || echo "mix not found in PATH"
        asdf which mix || echo "mix not found in asdf"
        
        mix local.hex --force
        mix local.rebar --force

    - name: Save asdf Cache
      if: (steps.asdf-install.outcome == 'success' || env.ASDF_INVALID == 'true') && steps.asdf-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v3
      with:
        path: |
          /Users/runner/.asdf
          ~/.asdf
        key: macos-asdf-${{ hashFiles('.tool-versions') }}

    - name: Carthage Cache
      uses: actions/cache@v4
      id: carthage-cache
      with:
        path: Carthage
        #key: carthage-deps-${{ hashFiles('Cartfile.resolved') }}
        key: carthage-deps
        #restore-keys: |
        #  carthage-deps-

    - name: Print Carthage Cache Status
      run: |
        ls -lah Carthage || true
        echo "Carthage Cache Hit: ${{ steps.carthage-cache.outputs.cache-hit }}"
        echo "Carthage Cache Key: carthage-deps-${{ hashFiles('Cartfile.resolved') }}"

    - name: Carthage Update
      id: carthage-update
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      if: steps.carthage-cache.outputs.cache-hit != 'true'
      run: |
        #source ~/.bashrc
        . $(brew --prefix asdf)/libexec/asdf.sh
        carthage update --use-xcframeworks
        ls -lah Carthage


    - name: Save carthage Cache
      if: steps.carthage-update.outcome == 'success' && steps.carthage-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v3
      with:
        path: |
          Carthage
        key:  carthage-deps

    - name: Print Cartfile.resolved Hash (After Update)
      if: steps.carthage-cache.outputs.cache-hit != 'true' # Only run if Carthage Update ran
      run: |
        echo "Hash of Cartfile.resolved after Carthage Update:"
        shasum Cartfile.resolved

    - name: Checkout elixir-app
      shell: bash
      run: |
        git clone https://github.com/adiibanez/desktop-example-app.git elixir-app

    - name: Phx deps Cache
      uses: actions/cache@v4
      id: phx-deps-cache
      with:
        path: |
          elixir-app/deps
          elixir-app/_build
        key: phx-deps-${{ hashFiles('elixir-app/mix.lock') }}
        restore-keys: |
          phx-deps-

    - name: Build with XCode
      id: build-app
      run: |
        #source ~/.bashrc
        . $(brew --prefix asdf)/libexec/asdf.sh
        xcodebuild -sdk iphonesimulator -arch arm64 -configuration Debug -scheme "example" -derivedDataPath build/

    - name: Save phx deps cache
      if: steps.build-app.outcome == 'success' && steps.phx-deps-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v3
      with:
        path: |
          elixir-app/deps
          elixir-app/_build
        key: phx-deps-${{ hashFiles('elixir-app/mix.lock') }}

    - name: Archive build artifacts
      uses: actions/upload-artifact@v4
      #uses: mmkal/artifact.ci/upload@main
      with:
        name: ios-build
        path: |
          build/Build/Products/Debug-iphonesimulator/
          build/Build/Products/**/*.app
        retention-days: 30

    - name: Get iPad Simulator UUID
      continue-on-error: true
      id: get_ipad_simulator_uuid
      run: |
        echo "--- Output of xcrun simctl list devices available ---"
        xcrun simctl list devices available
        echo "--- End of xcrun simctl list devices available output ---"

        # Extract UUID using less strict pattern matching
        ipad_simulators=$(xcrun simctl list devices available | grep 'iPad' | sed -n 's/.*(\([0-9A-F-]\{36\}\)).*/\1/p')

        echo "--- Available iPad Simulator UUIDs ---"
        echo "$ipad_simulators"
        echo "--- End of iPad Simulator UUIDs ---"

        if [[ -z "$ipad_simulators" ]]; then
          echo "::error::No available iPad simulators found."
          echo "IPAD_UUID=Shutdown" >> "$GITHUB_ENV"
          exit 1
        else
          # Get the first iPad simulator UUID from the list
          first_ipad_uuid=$(echo "$ipad_simulators" | head -n 1)
          echo "Selected iPad: $(xcrun simctl list devices available | grep "$first_ipad_uuid")"
          echo "IPAD_UUID=$first_ipad_uuid" >> "$GITHUB_ENV"
        fi

    - name: Boot iPad Simulator
      continue-on-error: true
      id: boot-simulator
      run: |
        echo "Booting simulator: ${{ env.IPAD_UUID }}"
        xcrun simctl boot ${{ env.IPAD_UUID }}

    - name: Install app on Simulator
      if: steps.boot-simulator.outcome == 'success'
      id: install-app
      run: xcrun simctl install ${{ env.IPAD_UUID }} build/Build/Products/Debug-iphonesimulator/TodoApp.app

    - name: Launch app on Simulator
      continue-on-error: true
      id: launch-app
      if: steps.install-app.outcome == 'success'
      run: xcrun simctl launch ${{ env.IPAD_UUID }} ${{ env.APP_BUNDLE_ID }}

    - name: Take Simulator Screenshot
      if: steps.boot-simulator.outcome == 'success'
      run: |
        echo "Going to sleep for 30sec ..."
        sleep 30
        echo "... back in town."
        SCREENSHOT_FILE="simulator_screenshot.jpg"
        xcrun simctl io booted screenshot "$SCREENSHOT_FILE"
        # xcrun simctl screenshot ${{ env.IPAD_UUID }} "$SCREENSHOT_FILE"
        echo "Simulator screenshot saved to $SCREENSHOT_FILE"

    - name: Upload Simulator Screenshot Artifact
      if: steps.boot-simulator.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: simulator-screenshot
        path: simulator_screenshot*

    - name: Capture Simulator Logs
      continue-on-error: true
      id: capture-logs
      if: steps.boot-simulator.outcome == 'success'
      run: |
        echo "" | xcrun simctl diagnose -b -X --no-archive
        # -udid=${{ env.IPAD_UUID }}

    - name: Upload Simulator Logs Artifact
      if: steps.capture-logs.outcome == 'success'
      uses: actions/upload-artifact@v4
      with:
        name: simulator-logs
        path: |
          /private/tmp/simctl_diagnose_*/*.log
          /private/tmp/simctl_diagnose_*/*.plist


    - name: Shutdown Simulator
      if: steps.boot-simulator.outcome == 'success'
      run: xcrun simctl shutdown ${{ env.IPAD_UUID }}